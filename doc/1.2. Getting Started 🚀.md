## 1.2. Getting Started ðŸš€

This section will guide you through installing Alvamind and setting up your first project.

### 1.2.1. Installation ðŸ“¦

Alvamind is distributed as an npm package. You can install it using your preferred package manager:

```bash
# Using npm
npm install alvamind

# Using yarn
yarn add alvamind

# Using pnpm
pnpm add alvamind

# Using Bun
bun add alvamind
```

**Dependencies:**

Alvamind has peer dependencies on `fp-ts` and `zod`. While `fp-ts` powers the internal functional composition and `zod` is optional, it's highly recommended for runtime validation and type inference. You should also install them:

```bash
npm install fp-ts zod
# or
yarn add fp-ts zod
# or
pnpm add fp-ts zod
# or
bun add fp-ts zod
```

### 1.2.2. Quick Start Example âš¡

Let's create a simple "Greeter" module to demonstrate the basics of Alvamind:

```typescript
// src/greeter.module.ts
import { Alvamind } from 'alvamind';

// Create a new Alvamind module
export const greeterModule = new Alvamind({
  name: 'GreeterModule',
})
.decorate('greet', (name: string) => `Hello, ${name}!`)
.derive(({ greet }) => ({ // Access the `greet` function
  greetUser: (name: string) => greet(name), // Expose a method
}));

// src/main.ts
import { greeterModule } from './greeter.module';

async function main() {
  const greeting = greeterModule.greetUser('World'); // Call the method. Types are inferred!
  console.log(greeting); // Output: Hello, World!
}

main();
```

**Explanation:**

1.  **`greeter.module.ts`:**
    *   We import the `Alvamind` class.
    *   We create a new module named `GreeterModule` using `new Alvamind()`.
    *   We use `.decorate('greet', ...)` to add a `greet` function to the module. The type of `name` is explicitly defined as string.
    *   We use `.derive(({ greet }) => ...)` to create and expose a `greetUser` method, which utilizes the `greet` function, showing explicit dependency. The type of `greet` is automatically infered.

2.  **`main.ts`:**
    *   We import the `greeterModule`.
    *   We call the `greetUser` method, and TypeScript *automatically knows* the expected argument type and the return type, thanks to Alvamind's type inference.
    *    No `any` or `unknown` type. Fully type safety.

**Running the Example:**

1.  Create the `src/greeter.module.ts` and `src/main.ts` files with the code above.
2.  Initialize a new TypeScript project (if you haven't already):
    ```bash
    npm init -y
    tsc --init # Creates tsconfig.json
    ```
3.  Make sure you have installed `alvamind`, `fp-ts`, and `zod`.
4.  Compile and run the code:
    ```bash
    tsc
    node src/main.js
    ```
    You should see "Hello, World!" printed to the console.

### 1.2.3. Basic Usage ðŸ§©

This quick start showed the most fundamental Alvamind concepts. Let's break down a slightly more complex example, demonstrating more features.

```typescript
// src/user.module.ts
import { Alvamind } from 'alvamind';
import { z } from 'zod';
import * as E from 'fp-ts/Either';
import {pipe} from 'fp-ts/function';

// Define a Zod schema for User (optional, but recommended)
const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

// Create a user service
const userService = {
  normalizeEmail: (email: string) => email.trim().toLowerCase(),
};


export const userModule = new Alvamind({
  name: 'UserModule',
  schema: userSchema, // Optional schema
})
.use(userService) // Inject the user service
.decorate('isValidUser', (user: unknown) =>
    pipe(
        user,
        userModule.validate, // Use the built-in validate method
        E.isRight
    )
)
.derive(({ normalizeEmail }) => ({
    createUser: (userData: z.infer<typeof userSchema>) => { // type safety
        const normalizedEmail = normalizeEmail(userData.email);

        if(!userModule.isValidUser({...userData, email: normalizedEmail})){
            throw new Error("Invalid user data");
        }

        return {
            ...userData,
            email: normalizedEmail,
            createdAt: new Date()
        };
    },
}))
.onStart(() => { // onStart lifecycle
    console.log("User module Started");
});

// src/main.ts
import { userModule } from './user.module';

async function main() {
    const newUser = { id: '123', name: 'Alice', email: ' ALICE@example.COM ' };
    const createdUser = userModule.createUser(newUser); // Type-safe!
    console.log(createdUser);
}

main();

```

Key takeaways and expanded explanations:

*   **Zod Schema (Optional, but Powerful):**  The `userSchema` (using `zod`) defines the shape of a User object.  This provides *runtime validation* and *type inference*.  Alvamind can leverage this schema for automatic validation using the `.validate()` method.
*   **`userService`:**  This demonstrates a simple service with a pure function (`normalizeEmail`). This service is *injected* into the module using `.use(userService)`.
*   **`.use()`:** This is the primary way to inject dependencies into an Alvamind module. The injected dependencies become available within `.derive()` and other methods.  This is how you compose modules together.
*   **`.decorate()`:**  Adds a new function (`isValidUser`) to the `userModule`. It is similar to `.derive`, but `.decorate` doesn't infer the return type as a module dependency to be used by other modules. It is more for helper function.
* **`.validate`**: this is a special method from Alvamind when you are using `schema:`.
*   **`.derive()`:**  This is where you define the core functionality of your module, building upon injected dependencies.  The return value of `.derive()` becomes part of the module's public API. The type of input parameter `userData` in `createUser` method is automatically inferred from `userSchema`.
*   **`.onStart()`:** This is a *lifecycle hook*.  The function provided to `.onStart()` is executed when the module is initialized.  There are other hooks like `.onStop()`, `.onError()`, etc.
*  **Type safety**: no `any` or `unknown` type.
*  **Pure Function**: `normalizeEmail` is pure function.
*   **Immutability:**  In `createUser`, we create a *new* object with the normalized email and `createdAt` property, rather than modifying the original `userData`.
*   **Explicit Dependencies:**  The `createUser` function depends on `normalizeEmail`.  This dependency is explicitly provided via `.derive(({ normalizeEmail }) => ...)`.

This example, while still relatively simple, showcases a much more complete picture of how you'd structure an Alvamind module:  defining types/schemas, injecting dependencies, composing functions, and using lifecycle hooks.  This structure promotes testability, maintainability, and type safety throughout your application.  The next sections will dive deeper into each of these concepts.
