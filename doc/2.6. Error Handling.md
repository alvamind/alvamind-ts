## 2.6. Error Handling in Alvamind ðŸš§

Alvamind promotes a robust and predictable approach to error handling, inspired by Railway-Oriented Programming (ROP).  This section explains the core concepts of ROP, how to use Alvamind's features for error handling, and best practices for handling errors in your applications.

### 2.6.1. Railway-Oriented Programming: The Two-Track Approach

Railway-Oriented Programming is a functional approach to error handling that visualizes the flow of execution as a railway track with two tracks:

*   **Success Track (ðŸŸ¢):**  Represents the normal flow of execution when everything goes as expected.
*   **Failure Track (ðŸ”´):** Represents the flow of execution when an error occurs.

The core idea is to chain functions together in a way that automatically switches to the failure track if an error occurs at any point.  This avoids nested `try-catch` blocks and makes error handling more explicit and predictable.

**Key Concepts:**

*   **`Either` Monad:**  Alvamind encourages the use of the `Either` monad (from `fp-ts`) to represent computations that can either succeed (returning a value) or fail (returning an error).  `Either` has two constructors:
    *   `E.right(value)`: Represents a successful result, containing the `value`.
    *   `E.left(error)`: Represents a failed result, containing the `error`.

*   **Chaining with `E.chain`:**  The `E.chain` function (from `fp-ts`) allows you to chain operations that return `Either` values. If any operation in the chain returns `E.left`, the subsequent operations are skipped, and the `E.left` value (the error) is propagated.

*   **Handling Both Tracks:**  The `E.fold` function (from `fp-ts`) allows you to handle both the success and failure cases at the end of the chain.

**Example:**

```typescript
import { Alvamind } from 'alvamind';
import * as E from 'fp-ts/Either';
import { pipe } from 'fp-ts/function';

const userModule = new Alvamind({ name: 'UserModule' })
.derive(()=>({
    validateUser: (input: unknown): E.Either<Error, { name: string }> => {
        if (typeof input === 'object' && input !== null && 'name' in input && typeof input.name === 'string') {
            return E.right({ name: input.name });
          }
        return E.left(new Error('Invalid user data'));
    },
    normalizeName: (user: { name: string }): { name: string } => ({
      ...user,
      name: user.name.trim().toLowerCase(),
    }),
    saveUser: (user: { name: string }) =>
      Promise.resolve({ id: '123', ...user }),
}))
.pipe(
  'processUser',
  ({ validateUser, normalizeName, saveUser }) => (input: unknown) =>
    pipe(
      validateUser(input),     // 1. Validate (returns Either)
      E.map(normalizeName),   // 2. Normalize (only called on success)
      TE.fromEither,          // 3. Convert Either to TaskEither for async
      TE.chain(saveUser)        // 4. Save (only called on success)
    )
);

const successResult = await userModule.processUser({ name: '  Alice ' }); // Success track
const failureResult = await userModule.processUser({ name: 123 });     // Failure track

//Handle Either using E.fold
pipe(
    successResult,
    E.fold(
        (error) => console.log('Error:', error.message),
        (user) => console.log('Success:', user)
    )
)
```

**Benefits of ROP:**

*   **Explicit Error Handling:**  Errors are handled explicitly and predictably.
*   **No Nested `try-catch`:**  Avoids the "pyramid of doom" of nested `try-catch` blocks.
*   **Improved Readability:**  The flow of execution is easier to follow.
*   **Composability:**  Error handling logic can be composed together just like other functions.

### 2.6.2. `.catch()` for Error Handling: Specific Error Types

The `.catch()` method allows you to register error handlers for specific error types. This provides a way to handle different types of errors in different ways.

```typescript
import { Alvamind } from 'alvamind';

class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

class DatabaseError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'DatabaseError';
    }
}

const userModule = new Alvamind({ name: 'UserModule' })
  .derive(() => ({
    validate: (input: {name: string}): {name: string} => {
        if(!input.name) {
            throw new ValidationError('Name is required'); // Throw specific error
        }
        return input;
    },
    saveToDatabase: async (data:{name: string}) => {
      // Simulate a database error
      throw new DatabaseError('Failed to connect to database');
    }
  }))
  .pipe(
    'createUser',
    ({validate, saveToDatabase}) => async (input: {name: string}) => {
        try {
            const validated = validate(input);
            return await saveToDatabase(validated);
        } catch(error) {
            //catch all error
            throw error;
        }
    }
  )
  .catch(ValidationError, (error, context) => { // Handle ValidationError
    console.error('Validation Error:', error.message);
    // Optionally update state or perform other actions
    context.state.set({ error: 'Validation failed' });
  })
  .catch(DatabaseError, (error) => { // Handle DatabaseError
    console.error('Database Error:', error.message);
  });

async function run() {
    await userModule.createUser({name: ''}); // Triggers ValidationError
    await userModule.createUser({name: 'test'}); // Trigger DatabaseError.
}
run();

```

**Explanation:**

1.  **Custom Error Types:**  We define `ValidationError` and `DatabaseError` as custom error types, extending the built-in `Error` class.
2.  **Throwing Errors:** The `validate` function throws a `ValidationError` if the input is invalid.  The `saveToDatabase` function simulates a database error by throwing a `DatabaseError`.
3.  **`.catch(ErrorType, handler)`:**
    *   The first argument is the *error type* you want to handle (e.g., `ValidationError`, `DatabaseError`).
    *   The second argument is a *handler function* that receives the error object and the Alvamind context.
4. **Try Catch:** Because we want to handle specific error type, so the pipeline is wrapped with `try-catch` block.

**Key Features of `.catch()`:**

*   **Type-Specific Handling:**  Handle different error types differently.
*   **Context Access:** The handler function has access to the Alvamind context, allowing you to update state or access dependencies.
*   **Multiple Handlers:**  You can register multiple `.catch()` handlers for different error types.
* **Error Propagation:** If an error is *not* caught by a `.catch()` handler, it will be thrown, can be caught using try-catch block.

### 2.6.3. `.retry()` for Retrying Operations: Handling Transient Errors

The `.retry()` method allows you to automatically retry a function if it fails. This is useful for handling transient errors, such as network timeouts or temporary database connection issues.

```typescript
import { Alvamind } from 'alvamind';

const networkModule = new Alvamind({ name: 'NetworkModule' })
  .derive(() => ({
    fetchData: async (url: string) => {
      // Simulate a flaky network request
      if (Math.random() < 0.5) {
        throw new Error('Network request failed');
      }
      return { data: 'Some data' };
    },
  }))
  .retry({
    attempts: 3, // Retry up to 3 times
    delay: 1000,  // Wait 1 second between retries
    backoff: true, // Use exponential backoff
    when: (error) => error.message === 'Network request failed', // Only retry specific errors
  })
  .pipe(
    'getData',
    ({ fetchData }) => async (url: string) => {
      // The `fetchData` function will be automatically retried if it fails
      return networkModule.execute(() => fetchData(url));
    }
  );

async function run() {
    const data = await networkModule.getData('https://example.com');
    console.log(data);
}
run();

```

**Explanation:**

1.  **`fetchData`:** Simulates a network request that might fail.
2.  **`.retry({ ... })`:**
    *   `attempts`: The maximum number of retry attempts.
    *   `delay`: The initial delay between retries (in milliseconds).
    *   `backoff`: If `true`, use exponential backoff (the delay increases with each attempt).
    *    `when`:  An optional function that takes the error object and returns `true` if the operation should be retried, or `false` otherwise.
3. **`networkModule.execute`**: This is from `.retry()` method to execute the operation and handle retry automatically.

**Key Features of `.retry()`:**

*   **Automatic Retries:** Handles transient errors without manual intervention.
*   **Configurable:**  Allows you to control the number of attempts, delay, backoff, and retry conditions.
*   **Error Filtering:**  You can specify which errors should trigger a retry.
* **Type safety:** Type is automatically inferred.

### 2.6.4. `.fallback()` for Default Values: Providing Alternatives

The `.fallback()` method allows you to provide a fallback value to be returned if an operation fails. This can be useful for providing default data or preventing errors from propagating.

```typescript
import { Alvamind } from 'alvamind';
import * as E from 'fp-ts/Either';
import { pipe } from 'fp-ts/function';

const userModule = new Alvamind({ name: 'UserModule' })
.derive(()=>({
    fetchUser: (id: string): E.Either<Error, {id: string, name: string}> => {
        if(id === '123') {
            return E.right({id, name: 'Alice'})
        }
        return E.left(new Error('User Not Found'));
    }
}))
.pipe(
    'getUser',
    ({fetchUser}) => (id: string) =>
    pipe(
      fetchUser(id),
      E.getOrElse(() => ({ id: 'default', name: 'Guest' })) // Fallback value
    )
)
.fallback((error) => {
    console.error('An error Occured', error);
    return {id: 'fallback', name: 'Unknown'};
});

const user1 = await userModule.getUser('123');     // Returns Alice
const user2 = await userModule.getUser('invalid'); // Returns Guest
```

**Explanation:**
- Using `E.getOrElse` from `fp-ts` to get the value from `Either`.
- Using `.fallback` method if error is occured.

**Key Features of `.fallback()`:**

*   **Error Prevention:** Prevents errors from crashing your application.
*   **Default Values:** Provides sensible defaults when data is unavailable.
*   **Simplified Logic:** Avoids complex conditional logic for handling missing data.

### 2.6.5. Custom Error Types: Improved Error Handling

Using custom error types (as shown in the `.catch()` example) is highly recommended.  This allows you to:

*   **Differentiate Errors:**  Distinguish between different types of errors (e.g., validation errors, network errors, database errors).
*   **Attach Metadata:**  Add additional information to your errors (e.g., error codes, context data).
*   **Handle Errors Specifically:**  Use `.catch()` to handle different error types in different ways.

```typescript
// (See .catch() example for custom error type definitions)
```

By combining Railway-Oriented Programming, `.catch()`, `.retry()`, `.fallback()`, and custom error types, Alvamind provides a comprehensive and robust error handling system that promotes predictable behavior, clean code, and improved maintainability. These tools allow you to handle errors gracefully, recover from failures, and build resilient applications.
