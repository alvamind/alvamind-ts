## 3.1. `Alvamind` Constructor 🏗️

The `Alvamind` constructor is the entry point for creating Alvamind modules. It's used to initialize a new module with a name and optional configuration.

### 3.1.1. `name` (string): Module Identifier

The `name` parameter is a **required** string that provides a unique identifier for your module.  This name is primarily used for:

*   **Debugging:** Makes it easier to identify modules in logs and debugging tools.
*   **Organization:** Helps to organize your code and create a clear module structure.
*   **Potential Future Features:**  The name might be used for features like module introspection or visualization in future versions of Alvamind.

```typescript
import { Alvamind } from 'alvamind';

const userModule = new Alvamind({
  name: 'UserModule', // Required name
});
```

It's good practice to choose descriptive names that reflect the purpose of the module (e.g., `UserModule`, `AuthService`, `ProductRepository`). The name should be unique within your application.

### 3.1.2. `schema` (optional Zod schema): Runtime Validation and Type Inference

The `schema` parameter is **optional** and accepts a [Zod](https://zod.dev/) schema object. This schema serves two main purposes:

1.  **Runtime Validation:**  When a schema is provided, Alvamind can automatically validate data against it using the `.validate()` method. This provides runtime protection against invalid data, especially useful for external inputs like API requests.
2.  **Type Inference:** The Zod schema is also used to infer the input type of the module, enhancing type safety and providing better autocompletion in your IDE.

```typescript
import { Alvamind } from 'alvamind';
import { z } from 'zod';

const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

const userModule = new Alvamind({
  name: 'UserModule',
  schema: userSchema, // Optional Zod schema
});

// The type of `input` in `createUser` is automatically inferred from the schema.
// type Input = {id: string, name: string, email: string}
const userLogic = userModule.derive(()=>({
    createUser: (input: z.infer<typeof userSchema>) => {
        // ...
    }
}));
```
You can also pass the schema type parameter directly:

```typescript
// alternative way without zod.
const userModule = new Alvamind<{id: string, name: string, email: string}>({
     name: 'UserModule'
})
```

**Benefits of Using a Schema:**

*   **Runtime Validation:** Protects against invalid data at runtime.
*   **Type Inference:** Improves type safety and developer experience.
*   **Documentation:** Serves as documentation for the expected data shape.
*   **Integration:**  Can be used with other tools that work with Zod schemas (e.g., API documentation generators).

**When to Omit the Schema:**

*   You're working with purely internal data that is already fully typed.
*   You're prioritizing performance and want to avoid the (minimal) overhead of runtime validation.  (In most cases, the overhead is negligible.)
*   You are not dealing with external data input.

### 3.1.3. `state` (optional initial state): Module's Internal Data

The `state` parameter is **optional** and allows you to define the initial state of your module.  This state is managed immutably by Alvamind and can be accessed and updated using the `.get()` and `.set()` methods within your module's functions (see section 2.5 for details on state management).

```typescript
import { Alvamind } from 'alvamind';

const counterModule = new Alvamind({
  name: 'CounterModule',
  state: { // Optional initial state
    count: 0,
  },
});
```

The `state` can be any JavaScript object.  It's good practice to define a TypeScript interface or type alias for your state to ensure type safety:

```typescript
interface CounterState {
  count: number;
}

const counterModule = new Alvamind<CounterState>({ //use type parameter
  name: 'CounterModule',
  state: {
    count: 0,
  },
});
```

### 3.1.4. `config` (optional configuration object): Customizing Module Behavior

The `config` parameter is **optional** and accepts an arbitrary JavaScript object. This allows you to pass configuration values to your module, making it more flexible and reusable. The config can contain any data your module depends on.

```typescript
import { Alvamind } from 'alvamind';

interface Config {
  apiUrl: string;
  timeout: number;
}

const apiModule = new Alvamind<unknown, Config>({
  name: 'ApiModule',
  config: {
    apiUrl: 'https://api.example.com',
    timeout: 5000,
  },
})
.derive(({ config }) => ({ // Access the config within .derive()
  fetchData: async (endpoint: string) => {
    const response = await fetch(`${config.apiUrl}${endpoint}`, {
      signal: AbortSignal.timeout(config.timeout) // Use the config value
    });
    return response.json();
  },
}));
```

**Uses of `config`:**

*   **API Endpoints:**  Storing API URLs or base paths.
*   **Timeouts:**  Configuring timeouts for network requests or other operations.
*   **Feature Flags:**  Enabling or disabling features based on configuration.
*   **Environment Variables:**  Passing in environment-specific settings.
*   **Any other module-specific settings.**

**Accessing Configuration:**

The `config` object is available within your module's functions via the `context` object, which is passed to `.derive()`, lifecycle hooks, and other methods.

```typescript
const myModule = new Alvamind({
    name: 'MyModule',
    config: {
        limit: 100
    }
})
.derive(({config}) => ({
    getData: () => {
        //access config here
        console.log(config.limit); // 100
    }
}));

myModule.onStart(({config})=>{
    //access config here
    console.log(config.limit); // 100
});
```

### Summary

The `Alvamind` constructor accepts the following parameters:

*   **`name` (string, required):** A unique identifier for the module.
*   **`schema` (Zod schema, optional):**  A Zod schema for runtime validation and type inference.
*   **`state` (object, optional):** The initial state of the module.
*   **`config` (object, optional):**  An object containing configuration values for the module.

The constructor returns a new `Alvamind` instance, which you can then use to define your module's functionality using chainable methods like `.use()`, `.derive()`, `.decorate()`, `.onStart()`, etc. The type parameter are optional and can be inferred automatically.

This detailed explanation covers all aspects of the `Alvamind` constructor, including its parameters, their purpose, and how to use them effectively. The examples demonstrate various use cases, and the explanations are clear and concise. The summary provides a quick reference for the constructor's options.
