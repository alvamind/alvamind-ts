## 2.4. Type System and Inference in Alvamind ðŸ¦¾

Alvamind is built on a foundation of strong type safety, leveraging TypeScript's powerful type system to its fullest potential.  This section explores the core concepts of Alvamind's type system, including type inference, generic types, type utilities, and optional schema validation.

### 2.4.1. Type Inference: Automatic Type Deduction

Type inference is a key feature of Alvamind, reducing the need for explicit type annotations and making your code more concise and readable.  Alvamind intelligently infers types based on:

*   **Module Configuration:** The `name`, optional `schema`, and initial `state` provided to the `Alvamind` constructor.
*   **`.use()`:**  The types of injected modules.
*   **`.derive()`:** The return type of the function passed to `.derive()`, as well as the types of any injected dependencies.
*   **`.decorate()`:**  Explicit type annotations are strongly recommended for decorated values.
*   **`.pipe()`:**  The input and output types of the functions in the pipeline.
* **Type Parameter:** Explicit type parameter in `Alvamind` constructor, and other methods.

```typescript
import { Alvamind } from 'alvamind';
import { z } from 'zod';

// 1. Schema-based inference
const userModule = new Alvamind({
  name: 'UserModule',
  schema: z.object({
    id: z.string(),
    name: z.string(),
    email: z.string().email(),
  }),
})
.derive(({ }) => ({ // No need to type dependencies explicitly
  // TypeScript infers the type of `input` based on the schema
  createUser: (input) => {
    return { ...input, createdAt: new Date() }; // Inferred return type
  },
}));

// 2. Inference from .use()
const loggerModule = new Alvamind({ name: 'LoggerModule' })
  .decorate('log', (message: string) => console.log(message));

const appModule = new Alvamind({ name: 'AppModule' })
  .use(userModule)
  .use(loggerModule)
  .derive(({ log, createUser }) => { // `log` and `createUser` types are inferred
    // ...
  });

// 3. Inference from .derive()
const mathModule = new Alvamind({ name: 'MathModule' })
  .derive(() => ({
    add: (a: number, b: number) => a + b, // Inferred return type: number
    multiply: (a: number, b: number) => a * b,
  }));

const sum = mathModule.add(2, 3); // TypeScript knows `sum` is a number

// 4. Inference from .pipe()
const pipelineModule = new Alvamind({name: 'PipelineModule'})
.derive(()=>({
    step1: (input: string) => parseInt(input),
    step2: (input: number) => input * 2,
    step3: (input: number) => `Result: ${input}`
}))
.pipe(
    'process',
    ({step1, step2, step3}) => (input: string) => {
        //type is automatically inferred.
        return pipe(
            step1(input),
            step2,
            step3
        )
    }
)
const pipeResult = await pipelineModule.process('12');

// 5. Type Parameter
const myModule = new Alvamind<{id: string}>({name: 'MyModule'})
.derive(()=>({
    process: (input: {id: string}) => { //type is automatically inferred
        return {result: input.id};
    }
}));
const moduleResult = await myModule.process({id: '123'});
```

**Benefits of Type Inference:**

*   **Reduced Boilerplate:**  Less code to write and maintain.
*   **Improved Readability:**  Code is cleaner and easier to understand.
*   **Enhanced Type Safety:**  TypeScript catches type errors automatically.
*   **Refactoring Confidence:**  Changes to your code are automatically checked for type correctness.

### 2.4.2. Generic Types: Reusable and Type-Safe Components

Alvamind supports generic types, allowing you to create reusable modules and functions that can work with different data types while maintaining type safety.

```typescript
import { Alvamind } from 'alvamind';

// Generic Alvamind module
const listModule = new Alvamind<{items: string[]}>({
  name: 'ListModule',
  state: { items: [] },
})
.derive(({ state }) => ({
    addItem: (item: string) => {
      state.set({ items: [...state.get().items, item] });
    },
    getItems: () => state.get().items,
}));

// Usage with different types
type User = { id: string; name: string };

const userListModule = new Alvamind<{users: User[]}>({ // Pass the type here.
    name: 'UserListModule',
    state: {users: []}
})
.derive(({state}) => ({
    addUser: (user: User) => {
        state.set({users: [...state.get().users, user]});
    },
    getUsers: () => state.get().users
}));

// Generic function within a module
const genericModule = new Alvamind({ name: 'GenericModule' })
  .derive(() => ({
    // Generic function
    identity: <T>(value: T): T => value,
  }));

const stringValue = genericModule.identity('hello'); // stringValue is a string
const numberValue = genericModule.identity(123);     // numberValue is a number
```

**Key Uses of Generics:**

*   Creating reusable modules that can work with different data types.
*   Writing generic functions that operate on various types.
*   Defining custom type utilities.
*   Improving type safety in complex scenarios.

### 2.4.3. Type Utilities: Powerful Type Manipulations

Alvamind provides a rich set of type utilities to help you work with types effectively.  These utilities allow you to:

*   **Simplify Complex Types:**  `Simplify<T>`
*   **Create Partial or Readonly Types:** `DeepPartial<T>`, `DeepReadonly<T>`
*   **Infer Types from Modules:** `InferInput<T>`, `InferState<T>`, `InferDeps<T>`
*   **Work with Function Types:** `AsyncFunction<T>`, `FunctionKeys<T>`, `PropertyKeys<T>`
*   **Perform Conditional Type Logic:** `If<C, T, F>`, `IsNever<T>`, `IsAny<T>`, `IsUnknown<T>`
*   **Manipulate Unions and Intersections:** `UnionToIntersection<U>`, `UnionToTuple<T>`
*   **Work with Paths:** `Path<T>`, `PathValue<T, P>`
*   ...and many more (see the full list in the API Reference).

```typescript
// Example usage of type utilities
import {
  Simplify,
  DeepPartial,
  InferInput,
  PathValue,
  Alvamind,
} from 'alvamind';

// Assume we have a module
const userModule = new Alvamind({
  name: 'UserModule',
  schema: z.object({ id: z.string(), name: z.string() }),
});

// Simplify
type ComplexType = { a: { b: { c: string } } };
type SimpleType = Simplify<ComplexType>; // { a: { b: { c: string } } } (no change, but can help with readability)

// DeepPartial
type PartialUser = DeepPartial<InferInput<typeof userModule>>; // { id?: string; name?: string }

// InferInput
type UserInput = InferInput<typeof userModule>; // { id: string; name: string }

// PathValue
type UserName = PathValue<{ user: { name: string } }, 'user.name'>; // string
```

These type utilities are invaluable for:

*   Writing reusable and type-safe code.
*   Creating custom type-level abstractions.
*   Improving the clarity and maintainability of your type definitions.
*   Working with complex data structures.

### 2.4.4. Schema Validation (Optional): Runtime Type Checking

While Alvamind's core focus is on compile-time type safety, it also supports *optional* runtime validation using Zod schemas.  This provides an additional layer of protection against invalid data, especially when dealing with external inputs (like API requests or user input).

```typescript
import { Alvamind } from 'alvamind';
import { z } from 'zod';
import * as E from 'fp-ts/Either'

const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

const userModule = new Alvamind({
  name: 'UserModule',
  schema: userSchema, // Provide the Zod schema
})
.derive(()=>({
    validate: (input: unknown): E.Either<z.ZodError, {id: string, name: string, email: string}> => {
        return userSchema.safeParse(input);
    }
}))
.pipe(
    'createUser',
    ({validate}) => (input: unknown) => {
        return pipe(
            validate(input),
            // E.map and etc.
        )
    }
);

// The `schema` is also available for use elsewhere, e.g., with Elysia.js:
// new Elysia().post('/users', ..., { body: userModule.context.schema })
```

**Benefits of Schema Validation:**

*   **Runtime Protection:** Catches errors that might slip through compile-time checks.
*   **Data Integrity:** Ensures that your data conforms to the expected shape and types.
*   **Improved Error Messages:** Zod provides detailed error messages that can help with debugging.
*   **Integration with Other Tools:** Zod schemas can be used with other libraries and tools (e.g., for API documentation or form validation).
*  **Type Inference:** Zod schemas provide excellent type inference.

**When to Use Schema Validation:**

*   When dealing with external inputs (API requests, user input, data from external services).
*   When you need to ensure data integrity at runtime.
*   When you want to leverage Zod's powerful validation features (e.g., custom validations, transformations).

**When Not to Use Schema Validation:**

*   When you're working with purely internal data that is already fully typed.
*   When performance is critical and the overhead of runtime validation is unacceptable (in most cases, the overhead is negligible).

Alvamind's type system, combining compile-time type safety with optional runtime validation, provides a robust and flexible approach to ensuring the correctness and reliability of your applications. The extensive use of type inference, generic types, and type utilities empowers you to write concise, maintainable, and type-safe code, catching errors early and improving developer productivity.
