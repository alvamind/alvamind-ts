## 2.1. Modules in Alvamind ðŸ“¦

Modules are the fundamental building blocks of Alvamind applications. They provide a way to organize your code into logical units, encapsulate functionality, manage dependencies, and promote reusability. This section explains the concept of modules in Alvamind, how to create them, configure them, and compose them together.

### 2.1.1. Creating Modules: The `Alvamind` Constructor

You create a new Alvamind module using the `Alvamind` constructor. The constructor accepts a configuration object that defines the module's name, optional schema, initial state, and configuration.

```typescript
import { Alvamind } from 'alvamind';
import { z } from 'zod';

// Define a Zod schema (optional)
const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

// Create a new module
const userModule = new Alvamind({
  name: 'UserModule', // Required: Unique name for the module
  schema: userSchema, // Optional: Zod schema for validation and type inference
  state: {           // Optional: Initial state of the module
    users: [],
    loading: false,
  },
  config: {          // Optional: Configuration values for the module
    apiUrl: '/api/users',
  },
});
```

**Explanation:**

*   **`name` (required):** A unique string identifier for the module.  Good practice is to use descriptive names like `UserModule`, `AuthService`, `ProductRepository`.
*   **`schema` (optional):**  A Zod schema that defines the shape of the data this module will handle.  This enables runtime validation and helps with type inference.
*   **`state` (optional):**  An object representing the initial state of the module. This state is managed immutably by Alvamind.
*   **`config` (optional):** An object containing configuration values specific to this module.

**Minimal Example:**

The simplest possible module only requires a name:

```typescript
const myModule = new Alvamind({ name: 'MyModule' });
```

### 2.1.2. Module Configuration: Customizing Behavior

The `config` option in the `Alvamind` constructor allows you to customize the behavior of your module.  You can pass in any data your module needs, such as API endpoints, timeouts, feature flags, or other settings.

```typescript
const apiModule = new Alvamind({
  name: 'ApiModule',
  config: {
    baseUrl: 'https://api.example.com',
    timeout: 5000,
    apiKey: 'your-api-key',
  },
});
```

You can access the configuration values within your module's functions using the `context` object:

```typescript
const apiModule = new Alvamind({
    name: 'ApiModule',
    config: {
      baseUrl: 'https://api.example.com',
      timeout: 5000,
      apiKey: 'your-api-key',
    },
  })
.derive(({ config }) => ({ // Access the config
  fetchData: async (endpoint: string) => {
    const response = await fetch(`${config.baseUrl}${endpoint}`, { // Use config values
      headers: {
        'Authorization': `Bearer ${config.apiKey}`,
      },
      signal: AbortSignal.timeout(config.timeout)
    });
    return response.json();
  },
}));
```

### 2.1.3. Module Composition (`.use()`): Building Larger Systems

The real power of Alvamind comes from its ability to compose modules together. The `.use()` method allows you to inject one module into another, creating a dependency relationship.

```typescript
// logger.module.ts
export const loggerModule = new Alvamind({ name: 'LoggerModule' })
  .decorate('log', (message: string) => console.log(`[LOG] ${message}`));

// user.module.ts
import { loggerModule } from './logger.module';

export const userModule = new Alvamind({ name: 'UserModule' })
  .use(loggerModule) // Inject the loggerModule
  .derive(({ log }) => ({ // Access the injected `log` function
    createUser: (name: string) => {
      log(`Creating user: ${name}`); // Use the injected dependency
      return { id: '123', name };
    },
  }));

// app.ts
import { userModule } from './user.module';
// Compose modules at the application level
const appModule = new Alvamind({ name: 'AppModule' }).use(userModule);
```

**Explanation:**

1.  **`loggerModule`:**  A simple module with a `log` function.
2.  **`userModule`:**
    *   `.use(loggerModule)`:  Injects the `loggerModule`.  This makes all of `loggerModule`'s exposed functionality (the `log` function in this case) available to `userModule`.
    *   `.derive(({ log }) => ...)`:  The `log` function is destructured from the dependencies object and used within the `createUser` function.
3. **`appModule`**: You can compose module into another Alvamind module.

**Benefits of Module Composition:**

*   **Code Reusability:**  Modules can be reused in different parts of your application or even in different projects.
*   **Separation of Concerns:**  Each module focuses on a specific area of functionality, making the code easier to understand and maintain.
*   **Testability:**  Modules can be tested in isolation by mocking their dependencies.
*   **Scalability:**  You can build large, complex applications by composing smaller, manageable modules.

### 2.1.4. Module Scope: Encapsulation and Information Hiding

Alvamind modules provide a degree of encapsulation.  Only the functions and values that are explicitly exposed through `.derive()` or `.decorate()` are accessible from outside the module.  Internal state and helper functions that are *not* exposed remain private to the module.

```typescript
const myModule = new Alvamind({ name: 'MyModule' })
  .decorate('helperFunction', () => { /* ... */ }) // Accessible
  .derive(() => {
    const internalFunction = () => { /* ... */ }; // Not accessible from outside

    return {
      exposedFunction: () => { /* ... */ }, // Accessible
    };
  });

// Accessible:
myModule.exposedFunction();
myModule.helperFunction();

// NOT accessible:
// myModule.internalFunction(); // Error: Property 'internalFunction' does not exist on type ...
```

**Benefits of Encapsulation:**

*   **Reduced Complexity:**  Hides internal implementation details, making the module easier to use.
*   **Improved Maintainability:**  Changes to the internal implementation of a module don't affect other parts of the application, as long as the public API remains the same.
*   **Preventing Accidental Modification:**  Protects internal state and functions from being accidentally modified from outside the module.

In summary, Alvamind modules provide a powerful and flexible way to structure your applications, promoting code organization, reusability, testability, and maintainability. They encourage a modular design, where your application is built by composing smaller, well-defined units of functionality. The combination of the `Alvamind` constructor, `.use()`, `.derive()`, `.decorate()`, and the concept of module scope provides a solid foundation for building robust and scalable applications.
