## 2.2. Dependency Injection in Alvamind ðŸ’‰

Dependency Injection (DI) is a core design pattern in Alvamind, promoting loose coupling, testability, and maintainability.  Instead of modules directly creating or importing their dependencies, they *declare* what they need, and Alvamind provides those dependencies.  This section explains Alvamind's DI mechanisms and how to use them effectively.

### 2.2.1. `.use()` for Modules: Composing Applications

The `.use()` method is the primary way to compose Alvamind modules and inject dependencies from one module into another. It's how you build up your application from smaller, independent parts.

```typescript
// logger.module.ts
import { Alvamind } from 'alvamind';

export const loggerModule = new Alvamind({ name: 'LoggerModule' })
  .decorate('log', (message: string) => console.log(`[LOG] ${message}`));

// user.module.ts
import { Alvamind } from 'alvamind';
import { loggerModule } from './logger.module';

export const userModule = new Alvamind({ name: 'UserModule' })
  .use(loggerModule) // Inject loggerModule
  .derive(({ log }) => ({ // Access the injected `log` function
    createUser: (name: string) => {
      log(`Creating user: ${name}`); // Use the injected dependency
      return { id: '123', name };
    },
  }));

// app.ts
import { userModule } from './user.module';

const app = new Alvamind({ name: 'App' })
  .use(userModule); // Compose the userModule into the main app

async function run() {
    const user = await app.createUser('Alice');
    console.log(user);
}
run();

```

**Explanation:**

1.  **`loggerModule`:**  Defines a simple logging module with a `log` function.
2.  **`userModule`:**
    *   `.use(loggerModule)`:  *Injects* the `loggerModule`. This makes all the functions/values exposed by `loggerModule` (in this case, `log`) available to `userModule`.
    *   `.derive(({ log }) => ...)`:  The `log` function is *destructured* from the dependencies object and can then be used within the `createUser` function.
3.  **`app`:** The main application module composes the `userModule`.

**Key Benefits of `.use()`:**

*   **Explicit Dependencies:**  It's immediately clear what a module depends on by looking at its `.use()` calls.
*   **Loose Coupling:** Modules don't directly create or import their dependencies, making them more independent and reusable.
*   **Testability:**  You can easily swap out real dependencies with mocks during testing.
*   **Composability:**  You can build complex applications by composing smaller, well-defined modules.
*   **Type safety:** Type is automatically inferred.

### 2.2.2. `.derive()` for Computed Dependencies: Building Functionality

The `.derive()` method is used to define the core functionality of your module, *building upon* the injected dependencies. It's where you create the functions and values that your module will expose to the rest of the application.

```typescript
// user.service.ts
import { Alvamind } from 'alvamind';

const hashService = { // Example of a service, it could be another Alvamind Module.
    hashPassword: async (password: string) => {
        return Bun.password.hash(password);
    }
}

export const userService = new Alvamind({ name: 'UserService' })
  .use(hashService) // Inject hashService.
  .derive(({ hashPassword }) => ({ // Destructure `hashPassword`
    createUser: async (name: string, pass: string) => {
      const hashedPassword = await hashPassword(pass); // Use the dependency
      return { id: '123', name, password: hashedPassword };
    },
  }));
```

**Explanation:**

1.  **`hashService`:** A simple object (it could also be an Alvamind module) that provides a `hashPassword` function.
2.  **`userService`:**
    *   `.use(hashService)`: Injects the `hashService`.
    *   `.derive(({ hashPassword }) => ...)`:
        *   The `hashPassword` function is destructured from the dependencies.
        *   A `createUser` function is defined, which uses the injected `hashPassword` function.
        *   The `createUser` method is automatically inferred as part of `userService` API.

**Key Features of `.derive()`:**

*   **Dependency Access:**  Provides access to all injected dependencies via destructuring.
*   **Function Definition:**  The primary place to define your module's functions.
*   **Return Value:** The object returned by `.derive()` becomes part of your module's public API.  This is what other modules can access when they `.use()` your module.
*   **Type Inference:**  Alvamind automatically infers the types of the functions and values you define within `.derive()`.
* **Multiple .derive():** You can use multiple `.derive()` in chaining.

### 2.2.3. `.decorate()` for Adding Properties: Extending Modules

The `.decorate()` method allows you to add new properties (functions, values, or objects) to your module. It's similar to `.derive()`, but it's typically used for adding utilities, helpers, or configuration values that are *not* derived from other dependencies. It's useful for adding functionality that doesn't depend on other injected modules, but still needs to be part of the module's API.

```typescript
// math.module.ts
import { Alvamind } from 'alvamind';

export const mathModule = new Alvamind({ name: 'MathModule' })
  .decorate('pi', 3.14159) // Add a constant
  .decorate('add', (a: number, b: number) => a + b) // Add a function
  .derive(({ add, pi }) => ({ // Access decorated values
    calculateCircleArea: (radius: number) => pi * radius * radius,
    sum: (a:number, b: number) => add(a,b)
  }));

const area = mathModule.calculateCircleArea(5); // Access the derived function
const sum = mathModule.sum(5, 3); // Access the derived function
console.log(mathModule.pi) // Access the decorated property: 3.14159
console.log(area); // 78.53975
console.log(sum); // 8
```

**Explanation:**

1.  **`.decorate('pi', 3.14159)`:** Adds a constant `pi` to the module.
2.  **`.decorate('add', (a, b) => a + b)`:** Adds an `add` function to the module.
3.  **`.derive(...)`:**  The `calculateCircleArea` function, defined within `.derive()`, can access the `pi` value that was added using `.decorate()`.

**Key Differences between `.derive()` and `.decorate()`:**

*   **Dependency Focus:** `.derive()` is primarily for building functionality *from* injected dependencies.  `.decorate()` is for adding properties that are *independent* of other dependencies.
*   **Return Value:**  `.derive()`'s return value becomes part of the module's API. `.decorate()` *adds* to module's existing API (including properties defined using `derive`).
*   **Type Inference:**  `.derive()` automatically infers the types. For `.decorate()`, it is best practice to provide explicit type annotations.

**When to use `.decorate()`:**

*   Adding constants or configuration values.
*   Adding utility functions that don't depend on injected services.
*   Adding helper methods.
*   Extending a module with additional functionality without modifying its core dependencies.

### 2.2.4. Injecting Non-Alvamind Values with `.inject()`

While `.use()` is designed for composing Alvamind modules, the `.inject()` method allows you to inject *arbitrary* values into your module's context.  This is useful for injecting dependencies that are not Alvamind modules, such as database connections, configuration objects, or third-party libraries.

```typescript

import { Alvamind } from 'alvamind';

// Assume `db` is a database connection object from some library
const db = {
  users: {
    create: async (data) => { /* ... */ },
    findMany: async () => { /* ... */ },
  },
};

const logger = {
    info: (message: string) => console.log(message)
}

const userModule = new Alvamind({ name: 'UserModule' })
  .inject({ db, logger }) // Inject the database connection and logger
  .derive(({ db, logger }) => ({ // Access the injected values
    createUser: async (data) => {
      logger.info('Creating user...'); // Use the injected logger
      return db.users.create(data);    // Use the injected database connection
    },
    getUsers: async () => {
        return db.users.findMany();
    }
  }));
```

Key differences with `.use()`:

*   `.use()` is for composing Alvamind *modules*.
*   `.inject()` is for injecting *any* value (objects, functions, primitives, etc.).
*  `.inject()` accept object, and `.use()` accept Alvamind module.

This detailed explanation covers all the core aspects of dependency injection in Alvamind, including `.use()`, `.derive()`, `.decorate()`, and `.inject()`, with clear examples and explanations of their differences and use cases. This provides a solid foundation for understanding how to structure and compose applications using Alvamind's DI system.
