## 2.3. Functional Composition in Alvamind ðŸ§©

Functional composition is the process of combining simpler functions to build more complex functions. It's a cornerstone of functional programming and a key feature of Alvamind. This section explains how Alvamind facilitates functional composition and the benefits it provides.

### 2.3.1. `.pipe()` for Pipelines: Linear Data Flow

The `.pipe()` method in Alvamind provides a way to create *pipelines* of functions. A pipeline is a sequence of functions where the output of one function becomes the input of the next. This creates a clear, linear flow of data through your application logic.  It's inspired by the Unix pipe operator (`|`), which does a similar thing with command-line programs.

```typescript
import { Alvamind } from 'alvamind';
import * as E from 'fp-ts/Either';

const userModule = new Alvamind({ name: 'UserModule' })
  .derive(() => ({
    validate: (input: unknown): E.Either<Error, { name: string }> => {
      // ... (validation logic, returns Either.right(data) or Either.left(error)) ...
      if (typeof input === 'object' && input !== null && 'name' in input && typeof input.name === 'string') {
        return E.right({name: input.name})
      }
      return E.left(new Error('Invalid input'));
    },
    normalize: (data: { name: string }) => ({
      ...data,
      name: data.name.trim().toLowerCase(),
    }),
    save: (data: { name: string }) =>
      Promise.resolve({ id: '123', ...data }),
  }))
  .pipe(
    // Create a pipeline using .pipe()
    'processUser', // Name of the pipeline
    ({ validate, normalize, save }) => (input: unknown) =>
      pipe(
        validate(input),   // 1. Validate the input
        E.map(normalize),   // 2. Normalize if validation succeeds
        TE.fromEither,       // 3. Convert Either to TaskEither
        TE.chain(save)       // 4. Save if normalization succeeds
      )
  );
// use it
const result = await userModule.processUser({name: '   alVA '}); // Either right or left
```

**Explanation:**

1.  **`validate`, `normalize`, `save`:**  These are simple functions (defined within `.derive()`) that perform individual steps in the user processing pipeline. `validate` return `Either` for railway-oriented approach.
2.  **`.pipe(...)`:**
    *   The first argument, `'processUser'`, is a *name* for the pipeline. This creates a new method on the `userModule` called `processUser`.
    *   The second argument is a function that receives the module's dependencies (in this case, `validate`, `normalize`, and `save`) and returns a *pipeline function*.
    *   The pipeline function takes an `input` and passes it through the sequence of functions: `validate`, then `normalize`, then `save`.
    *   `fp-ts` `pipe` and `Either` are used to compose function with error handling.
    *   `TE.fromEither` and `TE.chain` from `fp-ts` is used to convert `Either` to `TaskEither` so it can work with async `save` function.

**Key Benefits of `.pipe()`:**

*   **Readability:**  Pipelines make the flow of data very clear and easy to follow.
*   **Maintainability:**  It's easy to add, remove, or reorder steps in the pipeline.
*   **Testability:**  Each function in the pipeline can be tested independently.
*   **Composability:**  You can compose pipelines together to create even larger pipelines.
*   **Type Safety:** Alvamind infers the input and output types of the pipeline, ensuring type safety throughout the process.

### 2.3.2. `flow()` and `pipe()` (from fp-ts): The Power Behind the Scenes

Alvamind's `.pipe()` method is built on top of the `pipe` and `flow` functions from the `fp-ts` library.  While you can use Alvamind's `.pipe()` directly in most cases, understanding `pipe` and `flow` can be helpful, especially for more advanced composition scenarios. You can also use it *directly* in your Alvamind module.

*   **`pipe(value, ...fns)`:** Takes an initial *value* and applies a sequence of functions to it.

    ```typescript
    import { pipe } from 'fp-ts/function';

    const result = pipe(
      2,          // Initial value
      (x) => x * 3, // Function 1
      (x) => x + 1, // Function 2
      (x) => x.toString() // Function 3
    ); // result: "7"
    ```

*   **`flow(...fns)`:**  Takes a sequence of functions and returns a *new function* that applies those functions in sequence.  It's like `pipe`, but without the initial value.

    ```typescript
    import { flow } from 'fp-ts/function';

    const process = flow(
      (x: number) => x * 3,
      (x) => x + 1,
      (x) => x.toString()
    );

    const result = process(2); // result: "7"
    ```

**Using `flow` and `pipe` directly in Alvamind:**

```typescript
import { Alvamind } from 'alvamind';
import { flow, pipe } from 'fp-ts/function';
import * as E from 'fp-ts/Either';

const mathModule = new Alvamind({ name: 'MathModule' })
  .decorate('add', (a: number, b: number) => a + b)
  .decorate('multiply', (a: number, b: number) => a * b)
  .derive(({ add, multiply }) => ({
    // Using `flow` to create a reusable function
    addAndMultiply: flow(
      add,
      (sum) => multiply(sum, 2)
    ),

    // Using `pipe` directly
    process: (input: number) =>
      pipe(
        input,
        (x) => add(x, 5),
        (x) => multiply(x, 3),
        (x) => `Result: ${x}`
      ),

      validateAndProcess: flow(
          (input: unknown): E.Either<Error, number> => {
              if(typeof input === 'number') {
                  return E.right(input);
              }
              return E.left(new Error('Invalid input'));
          },
          E.map((x) => add(x, 5)),
          E.map((x) => multiply(x, 3)),
          E.map((x) => `Result: ${x}`)
      )
  }));

const result1 = mathModule.addAndMultiply(2, 3); // (2 + 3) * 2 = 10
const result2 = mathModule.process(5);         // (5 + 5) * 3 = "Result: 30"
const result3 = mathModule.validateAndProcess(5);
```

### 2.3.3. Composing Asynchronous Operations: Handling Promises

Functional composition works seamlessly with asynchronous operations (Promises). You can use `async/await` within your functions, and Alvamind will handle the asynchronous flow correctly. You can also use `Task` and `TaskEither` from `fp-ts` for more advanced asynchronous composition.

```typescript
import { Alvamind } from 'alvamind';
import * as TE from 'fp-ts/TaskEither';
import { pipe } from 'fp-ts/function';

const userModule = new Alvamind({ name: 'UserModule' })
  .derive(() => ({
    // Asynchronous functions
    fetchUser: (id: string): Promise<{ id: string; name: string }> =>
      Promise.resolve({ id, name: 'Alice' }),

    saveUser: (user: { id: string; name: string }) =>
      Promise.resolve({ ...user, saved: true }),

     //compose with TaskEither
     processUser: (id: string): TE.TaskEither<Error, {id: string, name: string, saved: boolean}> => {
        return pipe(
            TE.tryCatch(
                () => userModule.fetchUser(id),
                (reason) => new Error(String(reason))
            ),
            TE.chain((user) => TE.tryCatch(
                () => userModule.saveUser(user),
                (reason) => new Error(String(reason))
            ))
        )
     }
  }))
  .pipe(
    'getUser',
    ({ fetchUser, saveUser }) => async (id: string) => {
      const user = await fetchUser(id); // Await the Promise
      const savedUser = await saveUser(user); // Await the Promise
      return savedUser;
    }
  );

const user = await userModule.getUser('123');
const user2 = await userModule.processUser('123')(); // use TaskEither.
```

### 2.3.4. Composing with Error Handling: Railway-Oriented Programming

Alvamind encourages Railway-Oriented Programming (ROP) for error handling. This means treating errors as a separate "track" that your code can switch to.  The `Either` monad from `fp-ts` is commonly used for this.

```typescript
// (See previous examples for Either and ROP usage)
import { Alvamind } from 'alvamind';
import { pipe } from 'fp-ts/function';
import * as E from 'fp-ts/Either';

const orderModule = new Alvamind({ name: 'OrderModule' })
.derive(()=> ({
    validateOrder: (order: unknown): E.Either<Error, {id: string}> => {
        //return Either
        if(typeof order === 'object' && order !== null && 'id' in order && typeof order.id === 'string'){
            return E.right({id: order.id});
        }
        return E.left(new Error('Invalid order'));
    },

    processPayment: (order: {id: string}): E.Either<Error, {id: string, paymentId: string}> => {
        //return Either
        return E.right({...order, paymentId: '456'});
    },
}))
.pipe(
    'processOrder',
    ({validateOrder, processPayment}) => (order: unknown) =>
    pipe(
        validateOrder(order), // Returns Either
        E.chain(processPayment),  // Only called if validateOrder succeeds
        E.fold( // Handle both success and failure
            (error) => ({ status: 'error', error: error.message }),
            (result) => ({ status: 'success', order: result })
        )
    )
);

const result = await orderModule.processOrder({id: '123'}); // Success
const result2 = await orderModule.processOrder({id: 123}); // Failure
